var W=Object.defineProperty,b=Object.defineProperties;var j=Object.getOwnPropertyDescriptors;var i=Object.getOwnPropertySymbols;var p=Object.prototype.hasOwnProperty,k=Object.prototype.propertyIsEnumerable;var u=(a,o,t)=>o in a?W(a,o,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[o]=t,f=(a,o)=>{for(var t in o||(o={}))p.call(o,t)&&u(a,t,o[t]);if(i)for(var t of i(o))k.call(o,t)&&u(a,t,o[t]);return a},h=(a,o)=>b(a,j(o));var d=(a,o,t)=>new Promise((s,e)=>{var w=r=>{try{c(t.next(r))}catch(l){e(l)}},y=r=>{try{c(t.throw(r))}catch(l){e(l)}},c=r=>r.done?s(r.value):Promise.resolve(r.value).then(w,y);c((t=t.apply(a,o)).next())});let n=null;function A(){return d(this,null,function*(){if(n)return n;const a=yield fetch("/defaultVocabulary.json");if(!a.ok)throw new Error(`Failed to fetch vocabulary (${a.status})`);const o=yield a.json();return n=Object.entries(o).flatMap(([t,s])=>s.map(e=>h(f({},e),{category:t}))),n})}function g(){return d(this,null,function*(){const a=yield A();return console.info(`QuickSearch: loaded ${a.length} words`),a})}export{n as allWords,g as loadAllWords};
